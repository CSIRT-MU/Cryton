image: registry.gitlab.ics.muni.cz:443/cryton/configurations/ci-base:latest  # TODO: unnecessary?

variables:
  DOCKER_TLS_CERTDIR: "/certs"
  CRYTON_APP_DIRECTORY: "$CI_PROJECT_DIR/cryton/"

default:
  interruptible: true
  artifacts:
    expire_in: 30 days

stages:
  - test
  - publish
  - build
  - deploy

.documentation:
  image: registry.gitlab.ics.muni.cz:443/cryton/configurations/production-base:latest
  rules:
    - changes: # TODO
        #        - cryton/**/*
        #        - settings*
        #        - examples/**/*
        - mkdocs.yml
        - docs/**/*
        - .gitlab-ci.yml
    - when: never

# test
.tests:
  stage: test
  image: registry.gitlab.ics.muni.cz:443/cryton/configurations/ci-base:latest
  coverage: '/TOTAL.*\s+(\d+%)$/'
  rules:
    - changes:
        - cryton/**/*
        - tests/**/*
        - .coveragerc-*
        - settings*
        - .gitlab-ci.yml
        - poetry.lock
        - pyproject.toml
        - tox.ini
    - when: never

unit_tests:
  extends: .tests
  script:
    - tox run-parallel -- tests/unit_tests/ --cov=cryton --cov-config=.coveragerc-unit
    - cat coverage.readable

integration_tests:
  extends: .tests
  script:
    - tox run-parallel -- tests/integration_tests/ --cov=cryton --cov-config=.coveragerc-integration
    - cat coverage.readable

build_documentation:
  extends: .documentation
  stage: test
  before_script:
    - poetry install
  script:
    - poetry run mkdocs build

# publish
.publish:
  stage: publish
  rules:
    - if: $CI_SERVER_HOST != "gitlab.ics.muni.cz"
      when: never
    - if: $CI_COMMIT_TAG =~ /^[0-9]+\.[0-9]+\.([0-9]|[0-z])+$/ && $CI_COMMIT_REF_PROTECTED == "true"

# TODO: multi arch Docker images (use tags to define the runner)
# https://github.com/GoogleContainerTools/kaniko#creating-multi-arch-container-manifests-using-kaniko-and-manifest-tool
.build_docker_image:
  extends: .publish
  image:
    name: gcr.io/kaniko-project/executor:v1.19.2-debug
    entrypoint: [ "" ]
  variables:
    BUILD_TARGET: "target"
    LATEST_TAG: "latest"
    TAG_PREFIX: ""
    IMAGE_NAME_POSTFIX: ""
    DOCKERFILE: "Dockerfile"
  before_script:
    # Set variables
    - export IMAGE_VERSION_CURRENT=$CI_COMMIT_TAG
    - export IMAGE_VERSION_MINOR=${IMAGE_VERSION%.*}
    - export IMAGE_VERSION_MAJOR=${IMAGE_MINOR_VERSION%.*}
    - export IMAGE_TAG_CURRENT=$TAG_PREFIX$IMAGE_VERSION_CURRENT
    - export IMAGE_TAG_MINOR=$TAG_PREFIX$IMAGE_VERSION_MINOR
    - export IMAGE_TAG_MAJOR=$TAG_PREFIX$IMAGE_VERSION_MAJOR
    - export IMAGE_DESTINATION=$CI_REGISTRY_IMAGE$IMAGE_NAME_POSTFIX
    # Check variables
    - echo "CI_REGISTRY_IMAGE $CI_REGISTRY_IMAGE"
    - echo "IMAGE_DESTINATION $IMAGE_DESTINATION"
    - echo "BUILD_TARGET $BUILD_TARGET"
    - echo "IMAGE_TAG_CURRENT $IMAGE_TAG_CURRENT"
    - echo "IMAGE_TAG_MINOR $IMAGE_TAG_MINOR"
    - echo "IMAGE_TAG_MAJOR $IMAGE_TAG_MAJOR"
    - echo "LATEST_TAG $LATEST_TAG"
  script:
    - echo "{\"auths\":{\"${CI_REGISTRY}\":{\"username\":\"${CI_REGISTRY_USER}\",\"password\":\"${CI_REGISTRY_PASSWORD}\"}}}" > /kaniko/.docker/config.json
    - /kaniko/executor
      --context $CI_PROJECT_DIR
      --dockerfile $DOCKERFILE
      --target $BUILD_TARGET
      --skip-unused-stages
      --destination $IMAGE_DESTINATION:$IMAGE_TAG_CURRENT
      --destination $IMAGE_DESTINATION:$IMAGE_TAG_MINOR
      --destination $IMAGE_DESTINATION:$IMAGE_TAG_MAJOR
      --destination $IMAGE_DESTINATION:$LATEST_TAG
      --label version="$IMAGE_VERSION_CURRENT"
      --label commit="$CI_COMMIT_SHA"

upload_package_to_pypi:
  extends: .publish
  script:
    - poetry config pypi-token.pypi $PYPI_TOKEN
    - poetry publish --build

build_docker_image_cryton:
  extends: .build_docker_image
  variables:
    BUILD_TARGET: "cryton"
    DOCKERFILE: "Dockerfile"

build_docker_image_hive:
  extends: .build_docker_image
  variables:
    BUILD_TARGET: "hive"
    IMAGE_NAME_POSTFIX: "/hive"
    DOCKERFILE: "Dockerfile-hive"

build_docker_image_api_proxy:
  extends: .build_docker_image
  variables:
    BUILD_TARGET: "api-proxy"
    IMAGE_NAME_POSTFIX: "/api-proxy"
    DOCKERFILE: "Dockerfile-api-proxy"

build_docker_image_cli:
  extends: .build_docker_image
  variables:
    BUILD_TARGET: "cli"
    IMAGE_NAME_POSTFIX: "/cli"
    DOCKERFILE: "Dockerfile-cli"

build_docker_image_worker:
  extends: .build_docker_image
  variables:
    BUILD_TARGET: "worker"
    IMAGE_NAME_POSTFIX: "/worker"
    DOCKERFILE: "Dockerfile-worker"

build_docker_image_worker_kali:
  extends: .build_docker_image
  variables:
    BUILD_TARGET: "worker-kali"
    LATEST_TAG: "kali"
    TAG_PREFIX: "kali-"
    IMAGE_NAME_POSTFIX: "/worker"
    DOCKERFILE: "Dockerfile-worker"

# build
.pages:
  extends: .documentation
  variables:
    HTTPS_REMOTE: https://${PROJECT_BOT_USER}:${PROJECT_BOT_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
    PAGES_BRANCH: "pages"
  before_script:
    - apt update && apt install -y git
    - git config user.name $PROJECT_BOT_USER
    - git config user.email $PROJECT_BOT_USER@example.com
    - git fetch origin $PAGES_BRANCH
  rules:
    - if: $CI_SERVER_HOST != "gitlab.ics.muni.cz"
      when: never
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $CI_COMMIT_REF_PROTECTED == "true"
    - if: $CI_COMMIT_TAG =~ /^[0-9]+\.[0-9]+|x\.([0-9]|[0-z])+$/ && $CI_COMMIT_REF_PROTECTED == "true"

build_pages:
  extends: .pages
  stage: build
  script:
    - poetry install
    - git checkout -b $PAGES_BRANCH origin/$PAGES_BRANCH || echo "Pages branch not deployed yet."
    - git checkout $CI_COMMIT_SHA
    - |
      if [ -n $CI_COMMIT_TAG ]; then
        export DOCUMENTATION_VERSION=${CI_COMMIT_TAG%.*}
        export ALIAS=latest
      else
        export DOCUMENTATION_VERSION=master
        export ALIAS=""
      fi
    - poetry run mike deploy
      --update-aliases
      --push
      --remote $HTTPS_REMOTE
      --branch $PAGES_BRANCH
      --alias-type=redirect
      --deploy-prefix public
      $DOCUMENTATION_VERSION $ALIAS
# TODO: maybe unnecessary
#    - poetry run mike set-default
#      --push
#      --remote $HTTPS_REMOTE
#      --branch $PAGES_BRANCH
#      --deploy-prefix public
#      latest

# deploy
pages:
  extends: .pages
  stage: deploy
  script:
    - git checkout $PAGES_BRANCH
  artifacts:
    expire_in: 30 days
    paths:
      - public/

# TODO
# modules will be reworked to serve the purpose as the default/fallback modules
# tests will be in tests, modules in modules, readme in the documentation, example.py wont exist
# structure will remain the same for external modules

# Modules

#mod_cmd:
#  stage: test
#  script:
#    - poetry run pip install -r ../modules/mod_cmd/requirements.txt
#    - poetry run pytest ../modules/mod_cmd/
#  coverage: '/TOTAL.*\s+(\d+%)$/'
#  rules:
#    - changes:
#        - modules/mod_cmd/mod.py
#        - modules/mod_cmd/test_mod.py
#        - modules/mod_cmd/requirements.txt
#    - when: never
#
#mod_ffuf:
#  stage: test
#  script:
#    - poetry run pip install -r ../modules/mod_ffuf/requirements.txt
#    - poetry run pytest ../modules/mod_ffuf/
#  coverage: '/TOTAL.*\s+(\d+%)$/'
#  rules:
#    - changes:
#        - modules/mod_ffuf/mod.py
#        - modules/mod_ffuf/test_mod.py
#        - modules/mod_ffuf/requirements.txt
#    - when: never
#
#mod_medusa:
#  stage: test
#  script:
#    - poetry run pip install -r ../modules/mod_medusa/requirements.txt
#    - poetry run pytest ../modules/mod_medusa/
#  coverage: '/TOTAL.*\s+(\d+%)$/'
#  rules:
#    - changes:
#        - modules/mod_medusa/mod.py
#        - modules/mod_medusa/test_mod.py
#        - modules/mod_medusa/requirements.txt
#    - when: never
#
#mod_msf:
#  stage: test
#  script:
#    - poetry run pip install -r ../modules/mod_msf/requirements.txt
#    - poetry run pytest ../modules/mod_msf/
#  coverage: '/TOTAL.*\s+(\d+%)$/'
#  rules:
#    - changes:
#        - modules/mod_msf/mod.py
#        - modules/mod_msf/test_mod.py
#        - modules/mod_msf/requirements.txt
#    - when: never
#
#mod_nmap:
#  stage: test
#  script:
#    - poetry run pip install -r ../modules/mod_nmap/requirements.txt
#    - poetry run pytest ../modules/mod_nmap/
#  coverage: '/TOTAL.*\s+(\d+%)$/'
#  rules:
#    - changes:
#        - modules/mod_nmap/mod.py
#        - modules/mod_nmap/test_mod.py
#        - modules/mod_nmap/requirements.txt
#    - when: never
#
#mod_script:
#  stage: test
#  script:
#    - poetry run pip install -r ../modules/mod_script/requirements.txt
#    - poetry run pytest ../modules/mod_script/
#  coverage: '/TOTAL.*\s+(\d+%)$/'
#  rules:
#    - changes:
#        - modules/mod_script/mod.py
#        - modules/mod_script/test_mod.py
#        - modules/mod_script/requirements.txt
#    - when: never
#
#mod_wpscan:
#  stage: test
#  script:
#    - poetry run pip install -r ../modules/mod_wpscan/requirements.txt
#    - poetry run pytest ../modules/mod_wpscan/
#  coverage: '/TOTAL.*\s+(\d+%)$/'
#  rules:
#    - changes:
#        - modules/mod_wpscan/mod.py
#        - modules/mod_wpscan/test_mod.py
#        - modules/mod_wpscan/requirements.txt
#    - when: never
